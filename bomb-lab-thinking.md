## 总览

bomb lab 是CMU(卡内基·梅隆大学) 为其课程编写的一个有趣的实验作业, 在这里可以巩固之前的汇编知识  
下载链接 -> [来自官网 https://csapp.cs.cmu.edu/3e/labs.html](https://csapp.cs.cmu.edu/3e/bomb.tar)  

作业内容分为六个阶段(), 即输入六次相应的字符串提供给程序, 如果字符串(密码错误), 视为拆除炸弹失败, 程序exit  
只能拿到程序的可执行文件和部分源码, 具体的过程需要使用反汇编器 `objdump` 生成汇编文件, 结合gdb进行分析得到答案  
请在Linux系统下执行作业里的可执行文件  
bomb lab好像各个版本有所不同, 但是我觉得核心思路是一样的, 在此讨论我这个版本的一些思路与方法

## 入门 附phase_1思路

B站上有讲的很好的视频, 在此推荐[这个](https://www.bilibili.com/video/BV1RFxheeEcy/)  

观看完即可完成phase_1

## phase_2

首先对输入进行检查, 不符合规范会爆炸  
然后再考虑如何输入可以过后面的逻辑性检测

## phase_3

同样的, 首先对输入进行检查, 不符合规范会爆炸, 然后符合规范的数字的范围是0-7  
源码针对输入,每个值都通过switch语句生成了独特的值,可以直接跳转到最后的比较, 获取这些独特的值

## phase_4

一个递归函数, 可以还原成c代码, 方便分析其对输入密码处理的逻辑, 成功还原后会发现很容易得到其中一个答案  
其实不止一个答案, 本人使用了C程序辅助:
首先对输入进行检查, 不符合规范会爆炸, 然后符合规范的数字的范围是0-14 , 还原C代码并写出程序,   
将0-14所有数作为密码遍历输入到自己的程序中, 可以得到有4个符合的答案

## phase_5

汇编代码里有神秘的字符串常量地址, 用gdb打印这个地址, 可以得到神秘密码本对照表  
然后慢慢分析

## phase_6

首先对输入进行检查, 不符合规范会爆炸, 搞清楚输入规范    
直接定位会爆炸的检查, 最后那个对输入处理的逻辑极其复杂, 不好碰瓷, 花时间也长  
定位后发现, 生成的数组要从大到小排列, 调整输入的位置实现这一点

## secret_phase

阅读汇编代码, 发现还有一个名为 'secret_phase'的函数, 检查其被声明的条件, 让你的输入满足这个条件   
做完phase_6会自动进入隐藏关, 但是不难, 和phase_4一个思路, 在此不表

## 我的答案

没做完前不要看 :angry:

[这里是提示? ](./bombfield/answer_hint.txt)告诉你答案唯不唯一

[这里是答案](./bombfield/Reference_answer.txt)